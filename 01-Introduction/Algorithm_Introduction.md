## What is Algorithm?
**Definition:**
- Step-by-step procedure of solving a computational problem

## Difference between Algorithm and program

| Algorithm | Program |
| -- | --|
| Step-by-step procedure of solving a computational problem | Step-by-step procedure of solving a computational problem |

Both have the same definition

| Algorithm | Program |
| -- | --|
| Implemented during **Design phase** of software design lifecycle | Implemented during **Implementation phase** of software design lifecycle |
| Using simple English like statement without proper syntax i.e **pseudo lanugage** | Using **programming language** |
| Written by **person with enough knowledge of the domain** for which he/she is trying to solve a problem | Written by a **programmer** |
| As we write the procedure in pseudo lanugage. Hence, the algorithm is **Hardware and OS independent** | Programming language are **Hardware and OS dependent**. So is the program eventually |
| After writing an algorithm we **analyse** to check if the results are achievable and whether the algorithm is efficient | We run the program and **test** for the desired output |

## Priori analysis VS Posteriori testing

| Priori analysis | Posteriori testing |
| -- | -- |
| **Done on Algorithms** to study them in detail and understand how they work and get the result | **Done on program** to know the result post execution of it |
| The result is in terms of **time and space complexity** | The result is in terms of **watch time** its taking and the **amount of memory** it is consuming in tersm of bytes |
| As the purpose is to study algorithms, its **language and hardware independent** | As the results are in actual watch time and amount of memory the program takes to execute, its **language, hardware and exvironment/OS dependent** |

## Characteristics of Algorithm
|  |  |
|-- | -- |
| **Input** | Can take 0 or more inputs |
| **Output** | Must generate atleast 1 output/result |
| **Definiteness** | Every statement inside the algorithm must be unambigious and must have single and exact meaning. Every statement should be rational and  solvable. Eg. we cannot pass or ask our algorithm to store 	&radic;-2 as its imaginary and if we cannot solve it, we cannot ask our computers to solve that |
| **Finiteness** | Algorithm must terminate at some point |
| **Effectiveness** | There should not be unneccessary statements in the algorithm. Every statements objective should be to server some purpose for the desired outcome of an algorithm |
